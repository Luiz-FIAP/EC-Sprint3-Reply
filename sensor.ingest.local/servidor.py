from flask import Flask, request, jsonify
import oracledb
from datetime import datetime
from config import DB_CONFIG, SERVER_CONFIG, SENSOR_CONFIG, QUERY_CONFIG

app = Flask(__name__)

# *** Configura√ß√µes do Banco de Dados Oracle ***
DB_USER = DB_CONFIG["user"]
DB_PASSWORD = DB_CONFIG["password"] 
DB_DSN = DB_CONFIG["dsn"]
TABLE_NAME = DB_CONFIG["table_name"]

def conectar_db():
    """Conecta ao banco de dados Oracle."""
    try:
        conn = oracledb.connect(user=DB_USER, password=DB_PASSWORD, dsn=DB_DSN)
        cursor = conn.cursor()
        print("Conectado ao Oracle DB com sucesso!")
        return conn, cursor
    except oracledb.Error as error:
        print(f"Erro ao conectar ao Oracle: {error}")
        return None, None

def criar_tabela_se_nao_existir():
    f"""Cria a tabela '{TABLE_NAME}' no Oracle se ela n√£o existir e insere dados iniciais."""
    conn, cursor = conectar_db()
    if conn and cursor:
        try:
            cursor.execute(f"""
                CREATE TABLE {TABLE_NAME} (
                    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    timestamp_read TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    sensor_type VARCHAR2(50) NOT NULL,
                    sensor_value NUMBER(15,6) NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    CONSTRAINT chk_sensor_type CHECK (sensor_type IN (
                        'temperature', 'humidity', 'vibration', 'luminosity'
                    ))
                )
            """)
            
            print(f"Tabela '{TABLE_NAME}' criada com sucesso!")
            print("üì• Inserindo dados iniciais...")
            
            # Dados iniciais do arquivo initial_data.sql (sem IDs - Oracle gerar√° automaticamente)
            initial_data = [
                ('TO_TIMESTAMP(\'11/06/25 20:49:48\', \'DD/MM/YY HH24:MI:SS\')', 'temperature', 25.82273, 'TO_TIMESTAMP(\'11/06/25 20:49:49.117548\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:49:48\', \'DD/MM/YY HH24:MI:SS\')', 'humidity', 64.0259, 'TO_TIMESTAMP(\'11/06/25 20:49:49.261326\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:49:48\', \'DD/MM/YY HH24:MI:SS\')', 'vibration', 0, 'TO_TIMESTAMP(\'11/06/25 20:49:49.402366\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:49:48\', \'DD/MM/YY HH24:MI:SS\')', 'luminosity', 1925, 'TO_TIMESTAMP(\'11/06/25 20:49:49.555663\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:49:51\', \'DD/MM/YY HH24:MI:SS\')', 'temperature', 23.40572, 'TO_TIMESTAMP(\'11/06/25 20:49:52.157367\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:49:51\', \'DD/MM/YY HH24:MI:SS\')', 'humidity', 63.95142, 'TO_TIMESTAMP(\'11/06/25 20:49:52.271569\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:49:51\', \'DD/MM/YY HH24:MI:SS\')', 'vibration', 0, 'TO_TIMESTAMP(\'11/06/25 20:49:52.384481\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:49:51\', \'DD/MM/YY HH24:MI:SS\')', 'luminosity', 2037, 'TO_TIMESTAMP(\'11/06/25 20:49:52.506132\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:49:54\', \'DD/MM/YY HH24:MI:SS\')', 'temperature', 25.06869, 'TO_TIMESTAMP(\'11/06/25 20:49:55.315371\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:49:54\', \'DD/MM/YY HH24:MI:SS\')', 'humidity', 62.15697, 'TO_TIMESTAMP(\'11/06/25 20:49:55.496412\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:49:54\', \'DD/MM/YY HH24:MI:SS\')', 'vibration', 0, 'TO_TIMESTAMP(\'11/06/25 20:49:55.659210\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:49:54\', \'DD/MM/YY HH24:MI:SS\')', 'luminosity', 1897, 'TO_TIMESTAMP(\'11/06/25 20:49:55.805156\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:49:57\', \'DD/MM/YY HH24:MI:SS\')', 'temperature', 25.86161, 'TO_TIMESTAMP(\'11/06/25 20:49:58.191191\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:49:57\', \'DD/MM/YY HH24:MI:SS\')', 'humidity', 62.24759, 'TO_TIMESTAMP(\'11/06/25 20:49:58.376402\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:49:57\', \'DD/MM/YY HH24:MI:SS\')', 'vibration', 0, 'TO_TIMESTAMP(\'11/06/25 20:49:58.511941\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:49:57\', \'DD/MM/YY HH24:MI:SS\')', 'luminosity', 1955, 'TO_TIMESTAMP(\'11/06/25 20:49:58.641018\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:01\', \'DD/MM/YY HH24:MI:SS\')', 'temperature', 23.46455, 'TO_TIMESTAMP(\'11/06/25 20:50:01.218908\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:01\', \'DD/MM/YY HH24:MI:SS\')', 'humidity', 61.94318, 'TO_TIMESTAMP(\'11/06/25 20:50:01.350483\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:01\', \'DD/MM/YY HH24:MI:SS\')', 'vibration', 0, 'TO_TIMESTAMP(\'11/06/25 20:50:01.479273\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:01\', \'DD/MM/YY HH24:MI:SS\')', 'luminosity', 1968, 'TO_TIMESTAMP(\'11/06/25 20:50:01.594888\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:04\', \'DD/MM/YY HH24:MI:SS\')', 'temperature', 24.52751, 'TO_TIMESTAMP(\'11/06/25 20:50:04.244060\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:04\', \'DD/MM/YY HH24:MI:SS\')', 'humidity', 63.39873, 'TO_TIMESTAMP(\'11/06/25 20:50:04.384001\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:04\', \'DD/MM/YY HH24:MI:SS\')', 'vibration', 0, 'TO_TIMESTAMP(\'11/06/25 20:50:04.639264\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:04\', \'DD/MM/YY HH24:MI:SS\')', 'luminosity', 1892, 'TO_TIMESTAMP(\'11/06/25 20:50:05.062563\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:07\', \'DD/MM/YY HH24:MI:SS\')', 'temperature', 25.01051, 'TO_TIMESTAMP(\'11/06/25 20:50:07.711273\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:07\', \'DD/MM/YY HH24:MI:SS\')', 'humidity', 63.05423, 'TO_TIMESTAMP(\'11/06/25 20:50:07.911586\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:07\', \'DD/MM/YY HH24:MI:SS\')', 'vibration', 0, 'TO_TIMESTAMP(\'11/06/25 20:50:08.033813\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:07\', \'DD/MM/YY HH24:MI:SS\')', 'luminosity', 2219, 'TO_TIMESTAMP(\'11/06/25 20:50:08.176767\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:10\', \'DD/MM/YY HH24:MI:SS\')', 'temperature', 26.84347, 'TO_TIMESTAMP(\'11/06/25 20:50:10.519060\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:10\', \'DD/MM/YY HH24:MI:SS\')', 'humidity', 61.33479, 'TO_TIMESTAMP(\'11/06/25 20:50:10.650889\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:10\', \'DD/MM/YY HH24:MI:SS\')', 'vibration', 0, 'TO_TIMESTAMP(\'11/06/25 20:50:10.761398\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:10\', \'DD/MM/YY HH24:MI:SS\')', 'luminosity', 2151, 'TO_TIMESTAMP(\'11/06/25 20:50:10.881533\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:13\', \'DD/MM/YY HH24:MI:SS\')', 'temperature', 25.3664, 'TO_TIMESTAMP(\'11/06/25 20:50:13.545246\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:13\', \'DD/MM/YY HH24:MI:SS\')', 'humidity', 60.4604, 'TO_TIMESTAMP(\'11/06/25 20:50:13.685252\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:13\', \'DD/MM/YY HH24:MI:SS\')', 'vibration', 0, 'TO_TIMESTAMP(\'11/06/25 20:50:13.800108\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:13\', \'DD/MM/YY HH24:MI:SS\')', 'luminosity', 2147, 'TO_TIMESTAMP(\'11/06/25 20:50:13.914861\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:16\', \'DD/MM/YY HH24:MI:SS\')', 'temperature', 25.44935, 'TO_TIMESTAMP(\'11/06/25 20:50:16.639072\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:16\', \'DD/MM/YY HH24:MI:SS\')', 'humidity', 60.81597, 'TO_TIMESTAMP(\'11/06/25 20:50:16.788579\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:16\', \'DD/MM/YY HH24:MI:SS\')', 'vibration', 0, 'TO_TIMESTAMP(\'11/06/25 20:50:16.917787\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:16\', \'DD/MM/YY HH24:MI:SS\')', 'luminosity', 2034, 'TO_TIMESTAMP(\'11/06/25 20:50:17.237771\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:19\', \'DD/MM/YY HH24:MI:SS\')', 'temperature', 23.53227, 'TO_TIMESTAMP(\'11/06/25 20:50:19.610831\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:19\', \'DD/MM/YY HH24:MI:SS\')', 'humidity', 66.9216, 'TO_TIMESTAMP(\'11/06/25 20:50:19.735842\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:19\', \'DD/MM/YY HH24:MI:SS\')', 'vibration', 0, 'TO_TIMESTAMP(\'11/06/25 20:50:19.848380\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:19\', \'DD/MM/YY HH24:MI:SS\')', 'luminosity', 2157, 'TO_TIMESTAMP(\'11/06/25 20:50:19.968136\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:22\', \'DD/MM/YY HH24:MI:SS\')', 'temperature', 23.91521, 'TO_TIMESTAMP(\'11/06/25 20:50:22.614770\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:22\', \'DD/MM/YY HH24:MI:SS\')', 'humidity', 65.60718, 'TO_TIMESTAMP(\'11/06/25 20:50:22.741326\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:43\', \'DD/MM/YY HH24:MI:SS\')', 'luminosity', 2220, 'TO_TIMESTAMP(\'11/06/25 20:50:44.386715\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:46\', \'DD/MM/YY HH24:MI:SS\')', 'temperature', 25.00879, 'TO_TIMESTAMP(\'11/06/25 20:50:46.997870\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:46\', \'DD/MM/YY HH24:MI:SS\')', 'humidity', 60.21681, 'TO_TIMESTAMP(\'11/06/25 20:50:47.128453\', \'DD/MM/YY HH24:MI:SS.FF\')'),
                ('TO_TIMESTAMP(\'11/06/25 20:50:46\', \'DD/MM/YY HH24:MI:SS\')', 'vibration', 0, 'TO_TIMESTAMP(\'11/06/25 20:50:47.248652\', \'DD/MM/YY HH24:MI:SS.FF\')')
            ]
            
            # Insere os dados iniciais (sem especificar ID - deixa o Oracle gerar automaticamente)
            for data_row in initial_data:
                cursor.execute(f"""
                    INSERT INTO {TABLE_NAME} (timestamp_read, sensor_type, sensor_value, created_at)
                    VALUES ({data_row[1]}, '{data_row[2]}', {data_row[3]}, {data_row[4]})
                """)
            
            # Verifica quantos registros foram inseridos
            cursor.execute(f"SELECT COUNT(*) FROM {TABLE_NAME}")
            total_records = cursor.fetchone()[0]
            print(f"‚úÖ {total_records} registros inseridos com sucesso!")
            
            # Mostra distribui√ß√£o por tipo de sensor
            cursor.execute(f"""
                SELECT sensor_type, COUNT(*) as records_per_type 
                FROM {TABLE_NAME} 
                GROUP BY sensor_type 
                ORDER BY sensor_type
            """)
            for tipo, contagem in cursor.fetchall():
                print(f"üìä {tipo}: {contagem} registros")
            
            conn.commit()
            print("‚úÖ Tabela e dados iniciais criados com sucesso!")
            
        except oracledb.Error as error:
            if error.args[0].code == 955:  # ORA-00955: nome j√° existe
                print(f"A tabela '{TABLE_NAME}' j√° existe.")
            else:
                print(f"Erro ao criar a tabela: {error}")
                if conn:
                    conn.rollback()
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()
    else:
        print("N√£o foi poss√≠vel conectar ao DB para criar a tabela.")

criar_tabela_se_nao_existir()

def inserir_dados_sensor(sensor_type, sensor_value, timestamp_read=None):
    """Insere uma nova leitura de sensor na tabela."""
    conn, cursor = conectar_db()
    if conn and cursor:
        try:
            if timestamp_read is None:
                # Se n√£o fornecido, usa timestamp atual
                cursor.execute(f"""
                    INSERT INTO {TABLE_NAME} (sensor_type, sensor_value)
                    VALUES (:sensor_type, :sensor_value)
                """, sensor_type=sensor_type, sensor_value=sensor_value)
            else:
                # Converte timestamp de milissegundos para datetime
                timestamp_dt = datetime.fromtimestamp(timestamp_read/1000)
                cursor.execute(f"""
                    INSERT INTO {TABLE_NAME} (sensor_type, sensor_value, timestamp_read)
                    VALUES (:sensor_type, :sensor_value, :timestamp_read)
                """, sensor_type=sensor_type, sensor_value=sensor_value, 
                    timestamp_read=timestamp_dt)
            
            conn.commit()
            print(f"‚úÖ Dados inseridos: {sensor_type} = {sensor_value} @ {timestamp_dt if timestamp_read else 'now'}")
            return True
        except oracledb.Error as error:
            print(f"‚ùå Erro ao inserir dados: {error}")
            if conn:
                conn.rollback()
            return False
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()
    return False

def validate_sensor_data(sensor_type, sensor_value, timestamp=None):
    """
    Valida dados do sensor ANTES de tentar inserir no banco.
    Retorna (is_valid, error_message, http_code)
    """
    # 1. Validar timestamp se fornecido
    if timestamp is not None:
        try:
            # Verifica se o timestamp √© um n√∫mero v√°lido
            timestamp_float = float(timestamp)
            # Converte de milissegundos para segundos se necess√°rio
            if timestamp_float > 1e12:  # Se for em milissegundos
                timestamp_float = timestamp_float / 1000
            # Verifica se o timestamp est√° em um intervalo razo√°vel (entre 2024 e 2030)
            timestamp_dt = datetime.fromtimestamp(timestamp_float)
            min_date = datetime(2024, 1, 1)
            max_date = datetime(2030, 12, 31)
            if not (min_date <= timestamp_dt <= max_date):
                return False, f"Timestamp fora do intervalo v√°lido (2024-2030). Recebido: {timestamp_dt}", 400
        except (ValueError, TypeError, OSError) as e:
            return False, f"Timestamp inv√°lido: {str(e)}", 400

    # 2. Validar se o tipo de sensor √© suportado
    valid_types = SENSOR_CONFIG["valid_types"]
    if sensor_type not in valid_types:
        return False, f"Tipo de sensor inv√°lido. Tipos suportados: {valid_types}", 400
    
    # 3. Validar faixa de valores para cada tipo de sensor
    value_ranges = SENSOR_CONFIG["max_value_range"]
    if sensor_type in value_ranges:
        min_val, max_val = value_ranges[sensor_type]
        if not (min_val <= sensor_value <= max_val):
            return False, f"Valor fora da faixa v√°lida para {sensor_type}. Esperado: {min_val} - {max_val}, recebido: {sensor_value}", 400
    
    # 4. Valida√ß√µes espec√≠ficas por tipo de sensor
    if sensor_type == "vibration":
        # Vibra√ß√£o deve ser 0 ou 1 (digital)
        if sensor_value not in [0, 1]:
            return False, f"Sensor de vibra√ß√£o deve ser 0 (sem vibra√ß√£o) ou 1 (com vibra√ß√£o). Recebido: {sensor_value}", 400
    
    elif sensor_type == "luminosity":
        # Luminosidade deve ser inteiro (ADC)
        if not isinstance(sensor_value, (int, float)) or sensor_value < 0:
            return False, f"Sensor de luminosidade deve ser valor n√£o-negativo. Recebido: {sensor_value}", 400
        # Verificar se √© valor ADC v√°lido (0-4095 para ESP32)
        if sensor_value > 4095:
            return False, f"Valor de luminosidade muito alto (m√°ximo 4095 para ESP32). Recebido: {sensor_value}", 400
    
    elif sensor_type in ["temperature", "humidity"]:
        # Verificar precis√£o (n√£o mais que 2 casas decimais)
        if round(sensor_value, SENSOR_CONFIG["data_precision"]) != sensor_value:
            return False, f"Sensor {sensor_type} deve ter no m√°ximo {SENSOR_CONFIG['data_precision']} casas decimais", 400
    
    return True, None, None

@app.route('/data', methods=['POST'])
def receive_data():
    """Endpoint para receber dados dos sensores via POST."""
    try:
        # 1. Validar Content-Type
        if not request.is_json:
            return jsonify({
                "error": "Content-Type deve ser application/json",
                "details": "Envie dados no formato JSON com header 'Content-Type: application/json'"
            }), 400
        
        # 2. Validar se JSON √© v√°lido
        try:
            data = request.get_json()
        except Exception as e:
            return jsonify({
                "error": "JSON inv√°lido",
                "details": f"Erro ao interpretar JSON: {str(e)}"
            }), 400
        
        if not data:
            return jsonify({
                "error": "JSON vazio",
                "details": "Envie um objeto JSON com sensor_type e sensor_value"
            }), 400
        
        # 3. Extrair dados
        timestamp_param = data.get('timestamp')  # timestamp em milissegundos
        sensor_type = data.get('sensor_type')    # tipo do sensor
        sensor_value = data.get('sensor_value')  # valor lido

        # 4. Validar campos obrigat√≥rios
        if None in [sensor_type, sensor_value]:
            missing_fields = []
            if sensor_type is None:
                missing_fields.append("sensor_type")
            if sensor_value is None:
                missing_fields.append("sensor_value")
            
            return jsonify({
                "error": "Campos obrigat√≥rios ausentes",
                "missing_fields": missing_fields,
                "example": {
                    "sensor_type": "temperature",
                    "sensor_value": 25.5,
                    "timestamp": int(datetime.now().timestamp() * 1000)
                }
            }), 400

        # 5. Validar tipos de dados
        if not isinstance(sensor_type, str):
            return jsonify({
                "error": "sensor_type deve ser string",
                "received_type": str(type(sensor_type).__name__)
            }), 400

        try:
            sensor_value = float(sensor_value)
            timestamp = float(timestamp_param) if timestamp_param else None
        except (ValueError, TypeError):
            return jsonify({
                "error": "Tipos de dados inv√°lidos",
                "details": "sensor_value deve ser num√©rico, timestamp deve ser num√©rico (opcional)"
            }), 400

        # 6. ‚≠ê VALIDA√á√ÉO PRINCIPAL DO SENSOR (ANTES DO BANCO!)
        is_valid, error_msg, error_code = validate_sensor_data(sensor_type, sensor_value, timestamp)
        if not is_valid:
            print(f"‚ùå Valida√ß√£o falhou: {error_msg}")
            return jsonify({
                "error": "Dados do sensor inv√°lidos",
                "details": error_msg,
                "received_data": {
                    "sensor_type": sensor_type,
                    "sensor_value": sensor_value,
                    "timestamp": timestamp
                }
            }), error_code

        # 7. Se chegou aqui, dados s√£o v√°lidos - pode inserir no banco
        print(f"‚úÖ Dados v√°lidos: {sensor_type} = {sensor_value}")

        if inserir_dados_sensor(sensor_type, sensor_value, timestamp):
            return jsonify({
                "status": "success",
                "message": "Dados recebidos e armazenados com sucesso",
                "data": {
                    "sensor_type": sensor_type,
                    "sensor_value": sensor_value,
                    "timestamp": timestamp,
                    "datetime": datetime.fromtimestamp(timestamp/1000).isoformat() if timestamp else None
                }
            }), 200
        else:
            return jsonify({
                "status": "partial_success", 
                "message": "Dados v√°lidos recebidos mas falha ao armazenar no banco de dados",
                "details": "Verifique logs do servidor e conex√£o com Oracle"
            }), 202

    except Exception as e:
        print(f"‚ùå Erro inesperado no endpoint /data: {e}")
        return jsonify({
            "error": "Erro interno do servidor",
            "details": "Verifique logs do servidor para mais informa√ß√µes"
        }), 500

@app.route('/sensors', methods=['GET'])
def get_sensor_data():
    """Lista as leituras dos sensores com filtros opcionais."""
    conn, cursor = conectar_db()
    if not (conn and cursor):
        return jsonify({"error": "Erro de conex√£o com banco"}), 500

    try:
        sensor_type = request.args.get('sensor_type')
        limit = request.args.get('limit', str(QUERY_CONFIG["default_limit"]))
        
        query = f"""
            SELECT id, timestamp_read, sensor_type, sensor_value, created_at
            FROM {TABLE_NAME} 
        """
        params = {}
        
        if sensor_type:
            query += "WHERE sensor_type = :sensor_type "
            params['sensor_type'] = sensor_type
            
        query += "ORDER BY timestamp_read DESC FETCH FIRST :limit ROWS ONLY"
        params['limit'] = int(limit)

        cursor.execute(query, params)
        
        columns = [desc[0].lower() for desc in cursor.description]
        results = []
        
        for row in cursor:
            record = dict(zip(columns, row))
            # Converte timestamps para string ISO
            for key in ['timestamp_read', 'created_at']:
                if record[key]:
                    record[key] = record[key].isoformat()
            results.append(record)

        return jsonify({
            "status": "success",
            "count": len(results),
            "data": results
        })

    except Exception as e:
        print(f"‚ùå Erro ao consultar dados: {e}")
        return jsonify({"error": str(e)}), 500
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

@app.route('/health', methods=['GET'])
def health_check():
    """Endpoint de sa√∫de do servi√ßo."""
    conn, cursor = conectar_db()
    db_status = "ok" if (conn and cursor) else "error"
    
    if conn and cursor:
        cursor.close()
        conn.close()
    
    return jsonify({
        "status": "ok",
        "database": db_status,
        "timestamp": datetime.now().isoformat()
    })

if __name__ == '__main__':
    print("üöÄ Iniciando servidor de ingest√£o de dados IoT...")
    app.run(host=SERVER_CONFIG["host"], port=SERVER_CONFIG["port"], debug=SERVER_CONFIG["debug"]) 