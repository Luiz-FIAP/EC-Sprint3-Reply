from flask import Flask, request, jsonify
import oracledb
from datetime import datetime
from config import DB_CONFIG, SERVER_CONFIG, SENSOR_CONFIG, QUERY_CONFIG

app = Flask(__name__)

# *** Configurações do Banco de Dados Oracle ***
DB_USER = DB_CONFIG["user"]
DB_PASSWORD = DB_CONFIG["password"] 
DB_DSN = DB_CONFIG["dsn"]
TABLE_NAME = DB_CONFIG["table_name"]

def conectar_db():
    """Conecta ao banco de dados Oracle."""
    try:
        conn = oracledb.connect(user=DB_USER, password=DB_PASSWORD, dsn=DB_DSN)
        cursor = conn.cursor()
        print("Conectado ao Oracle DB com sucesso!")
        return conn, cursor
    except oracledb.Error as error:
        print(f"Erro ao conectar ao Oracle: {error}")
        return None, None

def criar_tabela_se_nao_existir():
    f"""Cria a tabela '{TABLE_NAME}' no Oracle se ela não existir."""
    conn, cursor = conectar_db()
    if conn and cursor:
        try:
            cursor.execute(f"""
                CREATE TABLE {TABLE_NAME} (
                    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    timestamp_read TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    sensor_type VARCHAR2(50) NOT NULL,
                    sensor_value NUMBER(10,2) NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    CONSTRAINT chk_sensor_type CHECK (sensor_type IN (
                        'temperature', 'humidity', 'vibration', 'luminosity'
                    ))
                )
            """)
            conn.commit()
            print(f"Tabela '{TABLE_NAME}' criada com sucesso!")
        except oracledb.Error as error:
            if error.args[0].code == 955:  # ORA-00955: nome já existe
                print(f"A tabela '{TABLE_NAME}' já existe.")
            else:
                print(f"Erro ao criar a tabela: {error}")
                if conn:
                    conn.rollback()
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()
    else:
        print("Não foi possível conectar ao DB para criar a tabela.")

criar_tabela_se_nao_existir()

def inserir_dados_sensor(sensor_type, sensor_value, timestamp_read=None):
    """Insere uma nova leitura de sensor na tabela."""
    conn, cursor = conectar_db()
    if conn and cursor:
        try:
            if timestamp_read is None:
                # Se não fornecido, usa timestamp atual
                cursor.execute(f"""
                    INSERT INTO {TABLE_NAME} (sensor_type, sensor_value)
                    VALUES (:sensor_type, :sensor_value)
                """, sensor_type=sensor_type, sensor_value=sensor_value)
            else:
                cursor.execute(f"""
                    INSERT INTO {TABLE_NAME} (sensor_type, sensor_value, timestamp_read)
                    VALUES (:sensor_type, :sensor_value, :timestamp_read)
                """, sensor_type=sensor_type, sensor_value=sensor_value, 
                    timestamp_read=datetime.fromtimestamp(timestamp_read/1000))
            
            conn.commit()
            print(f"Dados inseridos: {sensor_type} = {sensor_value}")
            return True
        except oracledb.Error as error:
            print(f"Erro ao inserir dados: {error}")
            if conn:
                conn.rollback()
            return False
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()
    return False

def validate_sensor_data(sensor_type, sensor_value):
    """
    Valida dados do sensor ANTES de tentar inserir no banco.
    Retorna (is_valid, error_message, http_code)
    """
    # 1. Validar se o tipo de sensor é suportado
    valid_types = SENSOR_CONFIG["valid_types"]
    if sensor_type not in valid_types:
        return False, f"Tipo de sensor inválido. Tipos suportados: {valid_types}", 400
    
    # 2. Validar faixa de valores para cada tipo de sensor
    value_ranges = SENSOR_CONFIG["max_value_range"]
    if sensor_type in value_ranges:
        min_val, max_val = value_ranges[sensor_type]
        if not (min_val <= sensor_value <= max_val):
            return False, f"Valor fora da faixa válida para {sensor_type}. Esperado: {min_val} - {max_val}, recebido: {sensor_value}", 400
    
    # 3. Validações específicas por tipo de sensor
    if sensor_type == "vibration":
        # Vibração deve ser 0 ou 1 (digital)
        if sensor_value not in [0, 1]:
            return False, f"Sensor de vibração deve ser 0 (sem vibração) ou 1 (com vibração). Recebido: {sensor_value}", 400
    
    elif sensor_type == "luminosity":
        # Luminosidade deve ser inteiro (ADC)
        if not isinstance(sensor_value, (int, float)) or sensor_value < 0:
            return False, f"Sensor de luminosidade deve ser valor não-negativo. Recebido: {sensor_value}", 400
        # Verificar se é valor ADC válido (0-4095 para ESP32)
        if sensor_value > 4095:
            return False, f"Valor de luminosidade muito alto (máximo 4095 para ESP32). Recebido: {sensor_value}", 400
    
    elif sensor_type in ["temperature", "humidity"]:
        # Verificar precisão (não mais que 2 casas decimais)
        if round(sensor_value, SENSOR_CONFIG["data_precision"]) != sensor_value:
            return False, f"Sensor {sensor_type} deve ter no máximo {SENSOR_CONFIG['data_precision']} casas decimais", 400
    
    return True, None, None

@app.route('/data', methods=['POST'])
def receive_data():
    """Endpoint para receber dados dos sensores via POST."""
    try:
        # 1. Validar Content-Type
        if not request.is_json:
            return jsonify({
                "error": "Content-Type deve ser application/json",
                "details": "Envie dados no formato JSON com header 'Content-Type: application/json'"
            }), 400
        
        # 2. Validar se JSON é válido
        try:
            data = request.get_json()
        except Exception as e:
            return jsonify({
                "error": "JSON inválido",
                "details": f"Erro ao interpretar JSON: {str(e)}"
            }), 400
        
        if not data:
            return jsonify({
                "error": "JSON vazio",
                "details": "Envie um objeto JSON com sensor_type e sensor_value"
            }), 400
        
        # 3. Extrair dados
        timestamp_param = data.get('timestamp')  # timestamp em millis
        sensor_type = data.get('sensor_type')    # tipo do sensor
        sensor_value = data.get('sensor_value')  # valor lido

        # 4. Validar campos obrigatórios
        if None in [sensor_type, sensor_value]:
            missing_fields = []
            if sensor_type is None:
                missing_fields.append("sensor_type")
            if sensor_value is None:
                missing_fields.append("sensor_value")
            
            return jsonify({
                "error": "Campos obrigatórios ausentes",
                "missing_fields": missing_fields,
                "example": {
                    "sensor_type": "temperature",
                    "sensor_value": 25.5,
                    "timestamp": 1234567890
                }
            }), 400

        # 5. Validar tipos de dados
        if not isinstance(sensor_type, str):
            return jsonify({
                "error": "sensor_type deve ser string",
                "received_type": str(type(sensor_type).__name__)
            }), 400

        try:
            sensor_value = float(sensor_value)
            timestamp_ms = float(timestamp_param) if timestamp_param else None
        except (ValueError, TypeError):
            return jsonify({
                "error": "Tipos de dados inválidos",
                "details": "sensor_value deve ser numérico, timestamp deve ser numérico (opcional)"
            }), 400

        # 6. ⭐ VALIDAÇÃO PRINCIPAL DO SENSOR (ANTES DO BANCO!)
        is_valid, error_msg, error_code = validate_sensor_data(sensor_type, sensor_value)
        if not is_valid:
            print(f"❌ Validação falhou: {error_msg}")
            return jsonify({
                "error": "Dados do sensor inválidos",
                "details": error_msg,
                "received_data": {
                    "sensor_type": sensor_type,
                    "sensor_value": sensor_value
                }
            }), error_code

        # 7. Se chegou aqui, dados são válidos - pode inserir no banco
        print(f"✅ Dados válidos: {sensor_type} = {sensor_value}")

        if inserir_dados_sensor(sensor_type, sensor_value, timestamp_ms):
            return jsonify({
                "status": "success",
                "message": "Dados recebidos e armazenados com sucesso",
                "data": {
                    "sensor_type": sensor_type,
                    "sensor_value": sensor_value,
                    "timestamp": timestamp_ms
                }
            }), 200
        else:
            return jsonify({
                "status": "partial_success", 
                "message": "Dados válidos recebidos mas falha ao armazenar no banco de dados",
                "details": "Verifique logs do servidor e conexão com Oracle"
            }), 202

    except Exception as e:
        print(f"❌ Erro inesperado no endpoint /data: {e}")
        return jsonify({
            "error": "Erro interno do servidor",
            "details": "Verifique logs do servidor para mais informações"
        }), 500

@app.route('/sensors', methods=['GET'])
def get_sensor_data():
    """Lista as leituras dos sensores com filtros opcionais."""
    conn, cursor = conectar_db()
    if not (conn and cursor):
        return jsonify({"error": "Erro de conexão com banco"}), 500

    try:
        sensor_type = request.args.get('sensor_type')
        limit = request.args.get('limit', str(QUERY_CONFIG["default_limit"]))
        
        query = f"""
            SELECT id, timestamp_read, sensor_type, sensor_value, created_at
            FROM {TABLE_NAME} 
        """
        params = {}
        
        if sensor_type:
            query += "WHERE sensor_type = :sensor_type "
            params['sensor_type'] = sensor_type
            
        query += "ORDER BY timestamp_read DESC FETCH FIRST :limit ROWS ONLY"
        params['limit'] = int(limit)

        cursor.execute(query, params)
        
        columns = [desc[0].lower() for desc in cursor.description]
        results = []
        
        for row in cursor:
            record = dict(zip(columns, row))
            # Converte timestamps para string ISO
            for key in ['timestamp_read', 'created_at']:
                if record[key]:
                    record[key] = record[key].isoformat()
            results.append(record)

        return jsonify({
            "status": "success",
            "count": len(results),
            "data": results
        })

    except Exception as e:
        print(f"❌ Erro ao consultar dados: {e}")
        return jsonify({"error": str(e)}), 500
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

@app.route('/health', methods=['GET'])
def health_check():
    """Endpoint de saúde do serviço."""
    conn, cursor = conectar_db()
    db_status = "ok" if (conn and cursor) else "error"
    
    if conn and cursor:
        cursor.close()
        conn.close()
    
    return jsonify({
        "status": "ok",
        "database": db_status,
        "timestamp": datetime.now().isoformat()
    })

if __name__ == '__main__':
    print("🚀 Iniciando servidor de ingestão de dados IoT...")
    app.run(host=SERVER_CONFIG["host"], port=SERVER_CONFIG["port"], debug=SERVER_CONFIG["debug"]) 