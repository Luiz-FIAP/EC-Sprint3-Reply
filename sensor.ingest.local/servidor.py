from flask import Flask, request, jsonify
import oracledb
from datetime import datetime
from config import DB_CONFIG, SERVER_CONFIG, SENSOR_CONFIG, QUERY_CONFIG

app = Flask(__name__)

# *** Configura√ß√µes do Banco de Dados Oracle ***
DB_USER = DB_CONFIG["user"]
DB_PASSWORD = DB_CONFIG["password"] 
DB_DSN = DB_CONFIG["dsn"]
TABLE_NAME = DB_CONFIG["table_name"]

def conectar_db():
    """Conecta ao banco de dados Oracle."""
    try:
        conn = oracledb.connect(user=DB_USER, password=DB_PASSWORD, dsn=DB_DSN)
        cursor = conn.cursor()
        print("Conectado ao Oracle DB com sucesso!")
        return conn, cursor
    except oracledb.Error as error:
        print(f"Erro ao conectar ao Oracle: {error}")
        return None, None

def criar_tabela_se_nao_existir():
    f"""Cria a tabela '{TABLE_NAME}' no Oracle se ela n√£o existir."""
    conn, cursor = conectar_db()
    if conn and cursor:
        try:
            cursor.execute(f"""
                CREATE TABLE {TABLE_NAME} (
                    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    timestamp_read TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    sensor_type VARCHAR2(50) NOT NULL,
                    sensor_value NUMBER(10,2) NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    CONSTRAINT chk_sensor_type CHECK (sensor_type IN (
                        'temperature', 'humidity', 'vibration', 'luminosity'
                    ))
                )
            """)
            conn.commit()
            print(f"Tabela '{TABLE_NAME}' criada com sucesso!")
        except oracledb.Error as error:
            if error.args[0].code == 955:  # ORA-00955: nome j√° existe
                print(f"A tabela '{TABLE_NAME}' j√° existe.")
            else:
                print(f"Erro ao criar a tabela: {error}")
                if conn:
                    conn.rollback()
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()
    else:
        print("N√£o foi poss√≠vel conectar ao DB para criar a tabela.")

criar_tabela_se_nao_existir()

def inserir_dados_sensor(sensor_type, sensor_value, timestamp_read=None):
    """Insere uma nova leitura de sensor na tabela."""
    conn, cursor = conectar_db()
    if conn and cursor:
        try:
            if timestamp_read is None:
                # Se n√£o fornecido, usa timestamp atual
                cursor.execute(f"""
                    INSERT INTO {TABLE_NAME} (sensor_type, sensor_value)
                    VALUES (:sensor_type, :sensor_value)
                """, sensor_type=sensor_type, sensor_value=sensor_value)
            else:
                cursor.execute(f"""
                    INSERT INTO {TABLE_NAME} (sensor_type, sensor_value, timestamp_read)
                    VALUES (:sensor_type, :sensor_value, :timestamp_read)
                """, sensor_type=sensor_type, sensor_value=sensor_value, 
                    timestamp_read=datetime.fromtimestamp(timestamp_read/1000))
            
            conn.commit()
            print(f"Dados inseridos: {sensor_type} = {sensor_value}")
            return True
        except oracledb.Error as error:
            print(f"Erro ao inserir dados: {error}")
            if conn:
                conn.rollback()
            return False
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()
    return False

@app.route('/data', methods=['POST'])
def receive_data():
    """Endpoint para receber dados dos sensores via POST."""
    try:
        # Recebe dados do corpo da requisi√ß√£o (JSON)
        if not request.is_json:
            return jsonify({
                "error": "Content-Type deve ser application/json"
            }), 400
            
        data = request.get_json()
        
        timestamp_param = data.get('timestamp')  # timestamp em millis
        sensor_type = data.get('sensor_type')    # tipo do sensor
        sensor_value = data.get('sensor_value')  # valor lido

        if None in [sensor_type, sensor_value]:
            return jsonify({
                "error": "Par√¢metros obrigat√≥rios: sensor_type, sensor_value"
            }), 400

        try:
            sensor_value = float(sensor_value)
            timestamp_ms = float(timestamp_param) if timestamp_param else None
        except (ValueError, TypeError):
            return jsonify({
                "error": "sensor_value deve ser num√©rico, timestamp deve ser num√©rico (opcional)"
            }), 400

        valid_types = SENSOR_CONFIG["valid_types"]
        if sensor_type not in valid_types:
            return jsonify({
                "error": f"sensor_type deve ser um de: {valid_types}"
            }), 400

        print(f"üì° Dados recebidos: {sensor_type} = {sensor_value}")

        if inserir_dados_sensor(sensor_type, sensor_value, timestamp_ms):
            return jsonify({
                "status": "success",
                "message": "Dados recebidos e armazenados com sucesso",
                "data": {
                    "sensor_type": sensor_type,
                    "sensor_value": sensor_value,
                    "timestamp": timestamp_ms
                }
            }), 200
        else:
            return jsonify({
                "status": "partial_success", 
                "message": "Dados recebidos mas falha ao armazenar no banco"
            }), 202

    except Exception as e:
        print(f"‚ùå Erro inesperado: {e}")
        return jsonify({"error": f"Erro interno: {str(e)}"}), 500

@app.route('/sensors', methods=['GET'])
def get_sensor_data():
    """Lista as leituras dos sensores com filtros opcionais."""
    conn, cursor = conectar_db()
    if not (conn and cursor):
        return jsonify({"error": "Erro de conex√£o com banco"}), 500

    try:
        sensor_type = request.args.get('sensor_type')
        limit = request.args.get('limit', str(QUERY_CONFIG["default_limit"]))
        
        query = f"""
            SELECT id, timestamp_read, sensor_type, sensor_value, created_at
            FROM {TABLE_NAME} 
        """
        params = {}
        
        if sensor_type:
            query += "WHERE sensor_type = :sensor_type "
            params['sensor_type'] = sensor_type
            
        query += "ORDER BY timestamp_read DESC FETCH FIRST :limit ROWS ONLY"
        params['limit'] = int(limit)

        cursor.execute(query, params)
        
        columns = [desc[0].lower() for desc in cursor.description]
        results = []
        
        for row in cursor:
            record = dict(zip(columns, row))
            # Converte timestamps para string ISO
            for key in ['timestamp_read', 'created_at']:
                if record[key]:
                    record[key] = record[key].isoformat()
            results.append(record)

        return jsonify({
            "status": "success",
            "count": len(results),
            "data": results
        })

    except Exception as e:
        print(f"‚ùå Erro ao consultar dados: {e}")
        return jsonify({"error": str(e)}), 500
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

@app.route('/health', methods=['GET'])
def health_check():
    """Endpoint de sa√∫de do servi√ßo."""
    conn, cursor = conectar_db()
    db_status = "ok" if (conn and cursor) else "error"
    
    if conn and cursor:
        cursor.close()
        conn.close()
    
    return jsonify({
        "status": "ok",
        "database": db_status,
        "timestamp": datetime.now().isoformat()
    })

if __name__ == '__main__':
    print("üöÄ Iniciando servidor de ingest√£o de dados IoT...")
    app.run(host=SERVER_CONFIG["host"], port=SERVER_CONFIG["port"], debug=SERVER_CONFIG["debug"]) 